#include <stdio.h>

int number = 10;
int data[10] = { 1,10,5,8,7,6,4,3,2,9 };

void quickSort(int *data, int start, int end) {
	if (start >= end) { //원소가 1개인 경우
		return;
	}
	int key = start; //피벗 값은 첫번째 원소로 한다.
	int i = start + 1;
	int j = end;
	int temp;
	
	while (i <= j) { //인덱스 역전 될때 까지
		while (data[i] <= data[key]) { // 피벗 값보다 큰값 만날때 까지
			i++;
		}
		while (data[j] >= data[key] && j > start) { //피벗 값보다 작은값 만날때 까지
			j--;
		}
		if (i > j) { // 현재 엇갈린 상태면 피벗값과 교체
			temp = data[j];
			data[j] = data[key];
			data[key] = temp;
		}
		else {
			temp = data[j];
			data[j] = data[i];
			data[i] = temp;
		}
	}

	quickSort(data, start, j - 1);
	quickSort(data, j + 1, end);
}

int main(void) {
	quickSort(data, 0, number - 1);
	for (int i = 0; i < number; i++) {
		printf("%d ", data[i]);
	}
	return 0;
}
//시간복잡도
//O(N * logN)
//분할정복 알고리즘

/*
예시
기준값(3) 7 8 1 5 9 6 10 2 4
- 기준값은 가장 첫번째 숫자다.
- 기준값을 제외하고 앞에서부터 기준값 보다 큰 값을 찾는다.
- 기준값을 제외하고 뒤에서부터 기준값 보다 작은 값을 찾는다.

기준값(3) 큰값(7) 8 1 5 9 6 10 작은값(2) 4
- 이렇게 찾은 값의 자리를 바꿔준다.

기준값(3) 2 8 1 5 9 6 10 7 4
... 반복한다...
기준값(3) 2 큰값(8) 작은값(1) 5 9 6 10 7 4
기준값(3) 2 1 8 5 9 6 10 7 4
기준값(3) 2 작은값(1) 큰값(8) 5 9 6 10 7 4
>> 이렇게 작은값 인덱스가 큰값 인덱스보다 작아지면 기준값과 작은값의 위치를 바꾼다.
기준값(1) 2 정렬완성(3) 8 5 9 6 10 7 4
>> 그리고 이렇게 바뀐 기준값은 정렬이 완료된것으로 간주합니다.
- 기준값(1) 2 정렬완성(3)| 기준값(8) 5 9 6 10 7 4 이렇게 나뉜다.
... 또 반복한다...
기준값(1) 큰값(2) 정렬완성(3)
>> 작은값이 없으므로 기준값은 정렬 완료된것으로 간주한다.
정렬완성(1) 기준값(2) 정렬완성(3)
>> 큰값도 작은값도 없기 때문에 2는 정렬이 완료된것으로 간주한다.
정렬완성(1) 정렬완성(2) 정렬완성(3) 기준값(8) 5 9 6 10 7 4
기준값(8) 5 큰값(9) 6 10 7 작은값(4)
- 바꿔준다.
기준값(8) 5 4 6 10 7 9
... 반복한다...
기준값(8) 5 4 6 큰값(10) 작은값(7) 9
기준값(8) 5 4 6 7 10 9
기준값(8) 5 4 6 작은값(7) 큰값(10) 9
>> 인덱스 역전이 되었기 때문에 20번과 같은 현상을 반복한다.
기준값(7) 5 4 6 정렬완성(8) 기준값(10) 9
...계속 반복해 나가면 정렬이된다...
*/