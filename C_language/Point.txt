컴퓨터의 메모리
    - 바이트 단위로 주소를 붙힌다.
    - 첫번째 바이트의 주소는 0, 두번째는 1 .... n-1
    - 주소로 메모리에 접근 가능

변수
    - 메모리에 저장된다.
    - 컴파일러에 의해 메모리 공간이 비어있는 위치에 할당된다.
    - 자료형에 따라 메모리에 차지하는 공간이 달라진다.
        - char 형 : 1바이트
        - int  형 : 4바이트
        - float형 : 4바이트
        // 하지만 포인터의 메모리 공간은 모두 4바이트로 동일하다.

포인터
    - ⭐메모리의 주소를 가지고 있는 변수
    - 사용하기 전에 선언되어야 한다.
        - ex) int *p; 
    - 포인터 이름은 식별자 규칙을 따른다.

주소는 메모리의 첫번째 공간을 말한다.

주소 연산자 &
    - 변수의 이름을 받아서 변수의 주소를 반환한다.
        - ex) int i;
              int a = &i;
              // a에 변수 i의 주소가 담긴다.

간접 참조 연산자
    - 포인터가 아무것도 가리키고 있는 않은 경우 NULL로 초기화
        - stdio.h에서 NULL은 0으로 정의되어 있다.
    - 포인터의 타입과 변수의 타입이 일치해야한다.
    - 포인터가 가리키는 주소에 저장 된 내용(값)을 읽는다.
    - 포인터를 통하여 메모리에 접근이 가능하다.
        - 메모리에 접근하여 저장 된 내용(값)을 변경할 수 있다.
    - ex)
            int i = 10;
            int* p; // 포인터 주소를 나타내는 변수
            p = &i;
            printf("%d === %d\n",i, *p); // 간접 참조 연산자
            *p = 50;
            printf("%d === %d\n",i,*p);

&연산자와 *연산자
    - &연산자
        - 변수에 주소를 반환한다.
    - *연산자
        - 포인터가 가리키는 곳의 내용(값) 빈환한다.

=====================================================================

포인터에 대해 가능한 연산
    - 증가 감소 덧셈 뺼셈 연산
    - 연산되는 값은 포인터가 가리키는 객체의 크기
    - 연산되는 값은 포인터가 가리키는 변수의 자료형의 크기
    - 자료형 크기
        - char   : 1 바이트
        - short  : 2 바이트
        - int    : 4 바이트
        - float  : 4 바이트
        - double : 8 바이트
    
    -ex)
        증가 전 char = 10,000, int = 10,000, double = 10,000
        증가 후 char = 10,001, int = 10,004, double = 10,008
        // 이렇게 포인터에 1을 더해주면 자료형 크기 만큼 증가한다.
        // 뺄셈도 동일하게 자료형 크기 만큼 감소한다.
    
    -⭐ *p++ 의 경우 주소를 증가시킨다.
    -⭐ (*p)++ 의 경우 주소가 가리키는 값을 증가시킨다.
        - v = *p++
            >> p가 가리키는 값을 v에 대입한 후에 p를 증가시킨다.
        - v = (*p)++
            >> p가 가리키는 값을 v에 대입한 후에 가리키는 값을 증가시킨다.
        - v = *++p
            >> p를 증가시킨 후에 p가 가리키는 값을 v에 대입한다.
        - v = ++*p
            >> p가 가리키는 값을 가져온 후에 그 값을 증가시켜 v에 대입한다.

        - ex)
            int main(void) {
	        int i = 10;
	        int* pi = &i;

	        printf("i = %d, pi = %d\n", i, pi);
            (*pi)++; // 값을 1 증가
    	    printf("i = %d, pi = %d\n", i, pi);
        	printf("\n\n");
	        printf("i = %d, pi = %d\n", i, pi);
    	    *pi++; // 주소를 1 증가
    	    printf("i = %d, pi = %d\n", i, pi);
            // pi의 주소값이 변경되었기 때문에 이제 *pi != i 이다.
    	    return 0;
            }

포인터와 함수
    - 값에 의한 호출
        - 함수로 복사본 전달
    - 참조에 의한 호출
        - 함수로 원본 전달

포인터와 배열
    - ⭐배열의 이름은 포인터 상수.
    - 배열의 시작 주소
    - 연산 불가능
        - ex) int a[] = {1,2,3};
              ++a; // 에러 발생

    - 포인터 배열 예제
            int main(void) {
	        int a[] = { 1,2,3,4,5 };
	        printf("&a[0] = %d\n", &a[0]);
	        printf("&a[1] = %d\n", &a[1]); // 4증가
	        printf("&a[2] = %d\n", &a[2]); // 4증가
	        printf("&a[3] = %d\n", &a[3]); // 4증가
	        printf("&a[4] = %d\n", &a[4]); // 4증가
            printf("a = %d\n", a); // &a[0] 과 동일
	        return 0;
            }

            int main(void) {
	        int a[] = { 1,2,3,4,5 };
	        printf("a = %d\n", a);
	        printf("a+1 = %d\n", a + 1);
	        printf("*a = %d\n", *a);
	        printf("*(a+1) = %d\n", *(a + 1));
	        return 0;
            }